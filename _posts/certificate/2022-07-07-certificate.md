---
title: "정보처리기사 필기 정리"
layout : single
author_profile : false
categories : 정보처리기사
published: true
toc : true
tag : [Engineer Information Processing, certificate, 정보처리기사]
sidebar :
    nav : "docs"
---

# 정보처리기사 필기 정리
## 1과목 : 소프트웨어 설계(20문제)
### 소프트웨어 개발의 생명주기 모형, SDLC(Software Development Life Cycle) ★★

1. 폭포수 모형(Waterfall Model) ★
- 가장 오래되고 폭넓게 사용된 **고전적 생명 주기** 모형
- 한 단계가 끝나야만 다음 단계로 넘어가는 **선형 순차적** 모형
- 단계별 정의 및 산출물이 **명확**
- 단점 : 개발 중간에 요구사항의 변경이 용이하지 않음
- 개발 순서
  - 폭포수의 물흐름처럼 한 번 지나가면 되돌릴 수 없듯이 각 단계를 명확히하고 다음 단계로 넘어감
  - **분설구테유** 
  - 타당성검토 → 계획 → 요구 **분**석 → **설**계 → **구**현(코딩) → **테**스트(검사) → **유**지보수(운용)

2. 프로토타입 모형(Prototype Model, 원형 모형) ★
- 사용자(고객)의 요구 기능에 대해 견본(시제)품을 만들어 검증하면서 최종 결과물을 예측하여 개발하는 모형
- 인터페이스 중점을 두어 개발
- 개발 중간에 **요구사항의 변경이 용이**
- 브룩스(Brooks)의 이론 : 폐기 처분을 주장
- 개발 순서
  - 요구 수집 → 빠른 설계 → 프로토타입 구축 → 고객 평가 → 프로토타입 조정

1. 나선형 모형(Spiral Model, 점진적 모형) ★
- 폭포수 모형과 프로토타입 모형의 장점에 **위험 분석** 기능을 추가한 모형
- 점진적 개발 과정 반복으로 요구사항 추가 가능
- 정밀하고 유지보수 과정 필요 없음
- 개발 순서
  - **계위개고**
  - **계**획 및 정의 → **위**험 분석 → 공학적 **개**발(Engineering) → **고**객 평가
- 특징
  - 계획 수립부터 모든 단계를 반복하며 개발

4. 애자일 모형(Agile Model) ★★
- 애자일은 **민첩함**, **기민함** 의미
- **변화에 유연**하게 대응
- **일정한 주기(Iteration, Sprint)**를 반복하면서 개발 과정 진행
- 절차와 도구보다** 고객(개인)과의 소통**에 초점을 맞춤
- **엑스칸크린**
  - **X**P(eXtreme Programming), **스**크럼(Scrum), **칸**반(Kanban), **크**리스탈(Crystal), **린**(LEAN) 
- 특징
  - **기능중심** 개발

5. V 모형
- **검증**을 강조한 기법
- 높은 **신뢰성**을 필요로 하는 의료 제어 시스템, 원자력 발전소 제어 시스템 등의 개발에 적합
- 개발 순서
  - 개발 준비 → 분석 → 설계 → 구현 → 시험 → 전개 → 인도
- 요구분석 검증, 인터페이스 검증, 모듈 검증

6. 4세대(4GT) 모형
- 개발자나 사용자(개발 요청자)가 쉽게 접근할 수 있는 4세대 언어를 이용한 기법
- 단점
  - 대규모 프로젝트에서 개발 시간이 오래 걸림 

---

### UML(Unified Modeling Language) ★★★
- **사관다**
  - **사**물, **관**계, **다**이어그램
- 1) **사**물(Things)
  - 구행그주
  - **구**조, **행**동, **그**룹, **주**해{사물}
- 2) 관계(Relationships) ★★
  - **연집포 일의실**
  - **연**관(ー)
  - **집**합(◇)
  - **포**함(◆)
  - **일**반화(ー▷)
  - **의**존(-->)
  - **실**체화(--▷){관계}
- 3) 다이어그램(Diagram) ★★
- 구조적, 정적 다이어그램
  - **클객컴 배복패**
  - **클**래스(Class)
  - **객**체(Object)
  - **컴**포넌트(Component) : 구현 단계에서 사용
  - **배**치(Deployment) : 구현 단계에서 사용
  - **복**합체 구조(Composite Structure)
  - **패**키지{다이어그램(Diagram)}
- 행위, 동적 다이어그램
  - **유시커 상활호타**
  - **유**스케이스(Use Case, 사용사례)
  - **시**퀀스(Sequence, 순차)
  - **커**뮤니케이션(Communication, 협업)
  - **상**태(State)
  - **활**동(Activity)
  - 상**호**작용 개요(Interaction Overview)
  - **타**이밍(Timing){다이어그램(Diagram)}

### OSI 7계층(Layer) ★★
- **아(A)파(P)서(S) 티(T)내(Ne)다(Da) 피(Phy)**나다
- ⑦ **응**용 계층(**A**pplication Layer)
  - **사용자와 네트워크 간** 응용서비스 연결, 데이터 생성
  - `HTTP`, `FTP`, `TELNET`, `SMTP/SNTP`, `DNS`
- ⑥ **표**현 계층(**P**resentation Layer)
  - 데이터 형식 설정, **코드변환**, **암/복호화**
  - `JPEG`, `MPEG`
- ⑤ **세**션 계층(**S**ession Layer)
  - **연결 접속(유지)**, 동기제어, **동기점(대화)**
  - `SSH`, `TLS`
- ④ **전**송 계층(**T**ransport Layer)
  - **종단간(End to End) 신뢰성** 있고 효율적인 데이터 전송, 데이터 분할, 재조립, 흐름 제어(슬라이딩 윈도우), 오류 제어, 혼잡 제어
  - `TCP/UDP`, `RTCP` → **세그먼트(Segment)**
- ③ **네**트워크 계층(**Ne**twork Layer)
  - 단말기 간 데이터 전송을 위한 최적화된 **경로(라우팅)** 제공
  - `IP`, `ICMP`, `IGMP`, `RIP`, `OSPF` → **패킷(Packet)**
- ② **데**이터 링크 계층(**Da**ta Link Layer)
  - **인접 시스템 간** 물리적 연결을 이횽해 데이터 전송, 동기화, 오류제어, 흐름제어, 오류검출 및 재전송
  - `HDLC`, `PPP`, `LLC`, `Ethernet(이더넷)` → **프레임(Frame)**
- ① **물**리 계층(**Phy**sical Layer)
  - 매체간의 **전기적, 기능적, 절차적** 기능 정의
  - `RS-232C` → **비트(Bit)**

---

### 객체 지향(Object-Oriented) ★★
1. 객체(Object)
- **독립적으로 식별 가능한 이름**을 가짐
- 객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함
- 객체와 객체는 상호 연관성에 의한 관계가 형성됨
- 객체가 반응할 수 있는 메세지의 집합을 행위(연산, Method)라고 하며, 객체는 행위의 특징을 나타냄
- 객체는 일정한 기억장소를 갖고 있음

2. 클래스(Class) ★★
- **하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것** ★
- 공통된 속성과 연산(행위)를 갖는 객체의 집합
- 객체지향 프로그램에서 **데이터를 추상화하는 단위** ★
- 각각의 **객체들이 갖는 속성과 연산(Method)을 정의**하고 있는 틀
- 슈퍼 클래스(Super Class)는 특정 클래스의 상위(부모) 클래스
- 서브 클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스

3. 인스턴스(Instance)
- 클래스에 속한 **각각의 객체**
- 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함

4. 메서드(Method)
- 클래스로부터 생성된 객체를 **사용하는 방법**
- 전통적 시스템의 **함수(Function)**또는 프로시저(Procedure)에 해당하는 **연산**

5. 메시지(Message)
- 객체에게 어떤 행위를 하도록 **지시하기 위한 방법**

6. 캡슐화(Encapsulation) ★
- **데이터**(속성)와 데이터를 처리하는 **함수**를 **하나로 묶는 것**
- 인터페이스를 제외한 세부 내용이 **은폐(정보 은닉)**되어 외부 접근이 제한됨
- **정보 은닉** 측면과 가장 밀접한 관계가 있음
- 외부 모듈의 변경으로 인한 **파급 효과가 적음**
- **재사용 용이**, **인터페이스 단순**해짐
- 결합도 Down / 응집도 Up

7. 상속(Inheritance)
- 이미 정의된 상위(부모) 클래스의 모든 속성과 연산을 하위(자식) 클래스가 물려받는 것
- 소프트웨어의 **재사용(Reuse)**를 높이는 중요한 개념

8. 다중 상속(Multiple Inheritance)
- 한 개의 클래스가 두 개 이상의 상위(부모) 클래스로부터 속성과 연산을 상속받는 것

9. 다형성(Polymorphism)
- 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 **고유한 방법(특성)으로 응답**할 수 있는 능력
  - Ex) `+` 연산자의 경우 숫자 클래스에서는 **덧셈**, 문자 클래스에서는 문자열의 **연결** 기능

---

### 객체 모델링 기법(OMT) / 럼바우의 객체 지향 분석 ★★
- **객동기**
- **객**체 모델링 : 객체 **다이어그램**
- **동**적 모델링 : **상태도**(상태 다이어그램)
- **기**능 모델링 : **자료 흐름도**

---

### 결합도(Coupling)
- 모듈 간에 상호 의존하는 정도 또는 두 **모듈 사이의 연관 관계**를 의미
- 결합도는 낮을수록 좋다 = 독립적인 모듈
- **내공외제 스자**

1. **내**용 결합도(Content Coupling)
- 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 **직접 참조**하거나 수정할 때의 결합도

2. **공**통 결합도(Common Coupling)
- 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도(**전역 변수**)

3. **외**부 결합도(External Coupling)
- 어떤 모듈에서 선언한 데이터(변수)를 **외부**의 다른 모듈에서 참조할 때의 결합도(**순차적**)

4. **제**어 결합도(Control Coupling)
- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 **제어**하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도

5. **스**탬프 결합도(Stamp Coupling)
- 모듈 간의 인터페이스로 배열이나 레코드 등의 **자료 구조**가 전달될 때의 결합도

6. **자**료 결합도(Data Coupling)
- 어떤 모듈이 다른 모듈을 호출하면서 **매개 변수(파라미터)**나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 결합도

---

### 응집도(Cohesion)
- 모듈의 **내부** 요소들의 서로 관련되어 있는 정도
- 응집도는 높을수록 좋다 = 독립적인 모듈
- **우논시절 통순기**

1. **우**연적 응집도(Coincidental Cohesion)
- 모듈 내부의 각 구성 요소들이 **서로 관련 없는 요소**로만 구성된 경우의 응집도

2. **논**리적 응집도(Logical Cohesion)
- 유사한 성격을 갖거나 **특정 형태**로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

3. **시**간적 응집도(Temporal Cohesion)
- **특정 시간**에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도

4. **절**차적 응집도(Procedural Cohesion)
- 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 **순차적**으로 수행할 경우의 응집도

5. **통**신적(교환적) 응집도(Communication Cohesion)
- **동일한** 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도

6. **순**차적 응집도(Sequential Cohesion)
- 모듈 내 하나의 활동으로부터 나온 **출력 데이터(출력값)**를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 

7. **기**능적 응집도(Functional Cohesion)
- 모듈 내부의 모든 **기능** 요소들이 단일 문제와 연관되어 수행될 경우의 응집도


---

### 코드
- **식분배간 표연암오**
- **식**별, **분**류, **배**열, **간**소화, **표**준화, **연**상, **암**호화, **오**류 검출 {기능}

1. 순차(순서) 코드(Sequence Code, 일련 번호 코드) ★
- 일정 기준에 따라서 최초의 자료부터 **차례로 일련번호를 부여**하는 방법
  - Ex) 1, 2, 3, 4 

2. 블록 코드(Block Code, 구분 코드) ★
- 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법
  - Ex) 1001~1100 : 총무부, 1101~1200 : 영업부 

3. 10진 코드(Decimal Code, 도서 분류식 코드) ★
- 0~9까지 10진 분할하고, 다시 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복하는 방법
  - Ex) 1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프트웨어 설계

4. 그룹 분류 코드(Group Classification Code)
- 일정 기준에 따라 **대분류, 중분류, 소분류** 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
  - Ex) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계

5. 연상 코드(Mnemonic Code, 기호 코드)
- 명칭이나 약호와 **관계있는 숫자나 문자, 기호**를 이용하여 코드를 부여하는 방법
  - Ex) TV-40 : 40인치 TV, L-15-220 : 15W 220V 램프

6. 표의 숫자 코드(Significant Digit Code, 유효 숫자 코드) ★
- 길이, 넓이, 부피, 지름, 높이 등의 **물리적 수치를 그대로 코드에 적용**시키는 방법

7. 합성 코드(Combined)
- **2개 이상의 코드를 조합**하여 만드는 방법
  - Ex) 연상 코드 + 순차 코드 → KE-711 : 대한항공 711기, AC-253 : 에어캐나다 253기

8. 코드 부여 체계
- **이름만으로 개체의 용도와 적용 범위를 알 수 있도록** 코드를 부여하는 방식
- 각 개체에 **유일한 코드를 부여**하여 개체들의 식별 및 추출을 용이하게 함
- **코드를 부여하기 전** 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드가 정의되어야 함
  - Ex) PJC-COM-003 : 전체 시스템 단위의 3번째 공통 모듈
  - Ex) PY3-MOD-010 : PY3라는 단위 시스템의 10번째 모듈 

---

### 디자인 패턴
#### 디자인 패턴(Design Pattern)이란?
- 소프트웨어 프로그램을 개발할때 참조할 수 있는 해결책 또는 예제
- 아키텍처 패턴이 디자인 패턴보다 상위 수준의 설계에 사용됨
- 서브시스템에 속하는 **컴포넌트들과 그 관계**를 설계하기 위한 참조 모델
cf) 아키텍처 패턴은 **전체 시스템의 구조**를 설계하기 위한 참조 모델

#### 목적에 따른 디자인 패턴 유형
- **생구행**

1. 생성 패턴(Creational Pattern) ★
- **추빌팩프싱**
- **추**상 팩토리(Abstract Factory) : 서로 연관, 의존하는 객체들을 그룹으로 생성해 추상적으로 표현
- **빌**더(Builder) : 객체의 생성 과정과 표현 방법 분리 → 동일한 객체를 생성해도 **서로 다른 결과**
- **팩**토리 메소드(Factory Method) : 객체를 생성하기 위한 인터페이스를 정의하여, 어떤 클래스가 인스턴스화될 것인지는 **서브클래스가 결정**하도록 하는 것(**Virtual-Constructor**패턴)
- **프**로토타입(Prototype) : 원본객체를 **복제**하는 방법으로 객체 생성 비용이 저렴
- **싱**글톤(Singleton) : 하나의 객체를 여러 프로세스가 **동시에 참조할 수 없음**

1. 구조 패턴(Structural Pattern) ★
- **어브컴데 퍼플프**
- **어**댑터(Adapter) : **호환성이 없는 클래스** 인터페이스를 이용할 수 있도록 변환해주는 패턴
- **브**리지(Bridge) : **구현부에서 추상층을 분리**하여 독립적으로 확장 및 다양성을 가지는 패턴
- **컴**포지트(Composite) : 여러 객체를 가진 **복합, 단일 객체**를 구분 없이 다룰 때 사용하는 패턴
- **데**코레이터(Decorator) : 상속을 사용하지 않고도 객체의 기능을 **동적으로 확장**해주는 패턴
- **퍼**싸드(Facade) : 서브 클래스들의 **기능을 간편하게** 사용할 수 있도록 하는 패턴 Ex) 리모컨
- **플**라이웨이트(Flyweight) : **공유**해서 사용함으로써 **메모리를 절약**하는 패턴
- **프**록시(Proxy) : **접근이 어려운 객체**를 연결해주는 **인터페이스 역할**을 수행하는 패턴

3. 행위 패턴(Behavioral Pattern)
- 생성 패턴과 구조 패턴에 **해당 안되면 행위 패턴**
- 책임 연쇄(Chain of Responsibility) : 한 객체가 처리하지 못하면 **다음 객체로 넘어가는** 패턴
- 커맨드(Command) : 요청에 사용되는 각종 **명령어**들을 추상, 구체 클래스로 분리하여 단순화함
- 인터프리터(Interpreter) : 언어에 **문법 표현을 정의**하는 패턴
- 반복자(Iterator) : **동일한 인터페이스를 사용**하도록 하는 패턴
- 중재자(Mediator) : **서로의 존재를 모르는 상태**에서도 **협력**할 수 있게 하는 패턴
- 메멘토(Memento) : 요청에 따라 객체를 해당 시점의 상태로 **돌릴 수 있는 기능을 제공**하는 패턴
- 옵저버(Observer) : **관찰 대상**의 변화를 **탐지**하는 패턴
- 상태(State) : 객체의 **상태에 따라** 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 전략(Strategy) : 클라이언트에 **영향을 받지 않는 독립적인 알고리즘**을 선택하는 패턴
- 템플릿 메소드(Template Method) : 유사한 서브 클래스를 묶어 **공통된 내용을 상위 클래스에 정의**하는 패턴
- 방문자(Visitor) : 필요할 때마다 해당 클래스에 **방문해서 처리**하는 패턴

---

### 인터페이스 방법 명세화
1. 시스템 연계 기술


2. 인터페이스 통신 유형


3. 인터페이스 처리 유형


4. 인터페이스 발생 주기


---

### 미들웨어(Middleware) 솔루션 명세
- 미들웨어(Middleware) : 운영체제(OS)와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외의 추가적인 서비스를 제공하는 **소프트웨어**
- **디원메트 레객와**

1. DB(Database)
- 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어, **2-Tier 아키텍처**
  - `ODBC(마이크로소프트)`, `IDAPI(볼랜드)`, `Glue(오라클)`

2. RPC(Remote Procedure Call, **원**격 프로시저 호출)
- 응용 프로그램의 프로시저를 사용하여 **원격 프로시저를 로컬 프로시저처럼 호출**하는 미들웨어
  - `Entera(이큐브시스템스)`, `ONC/RPC(OSF)`

3. MOM(Message Oriented Middleware, **메**시지 지향 미들웨어) ★
- **메시지 기반**의 **비동기형 메시지를 전달**하는 방식의 미들웨어
  - `MQ(IBM)`, `Message Q(오라클)`, `JMS(JCP)`

4. TP-Monitor(Transaction Processing Monitor, **트**랜잭션 처리 모니터) ★
- **항공기나 철도 예약 업무** 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어
- 사용자 수가 증가해도** 빠른 응답 속도를 유지**해야 하는 업무에 주로 사용됨

5. Legacyware(**레**거시웨어)
- 기존 애플리케이션에 **새로운 업데이트된 기능을 덧붙이고자** 할 때 사용되는 미들웨어

6. ORB(Object Request Broker, **객**체 요청 브로커) ★
- 객체 지향 미들웨어로 **코바(CORBA)** 표준 스펙을 구현한 미들웨어
  - 코바(CORBA, Common Object Request Broker Architecture) : 네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격을 의미
- 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음
  - `CORBA(OMG)`, `Orbix(Micro Focus)`

7. **WA**S(Web Application Server, 앱 애플리케이션 서버)
- 사용자의 요구에 따라 변하는 **동적인 콘텐츠를 처리**하기 위해 사용되는 미들웨어
  - Cf) 웹 서버(Web Server) : 클라이언트로부터 직접 요청을 받아 처리, 저용량의 **정적인 콘텐츠**(파일)들을 처리/제공하는 소프트웨어
- 클라이언트/서버 환경보다는 **웹 환경을 구현**하기 위한 미들웨어
- HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현 가능
  - `Web Logic(오라클)`, `WebSphere(IBM)`, `JEUS`, `Tomcat`

---

### XP(eXtreme Programming) 기법 ★ 
1. XP의 핵심 가치
- **용단의피존**
- **용**기(Courage)
- **단**순성(Simplicity)
- **의**사소통(Communication)
- **피**드백(Feedback)
- **존**중(Respect)

2. XP의 기본 원리
- **전소테 계공짝디**
- **전**체 팀(Whole Team)
- **소**규모 릴리즈(Small Releases)
- **테**스트 주도 개발(Test-Driven Development)
- **계**속적인 통합(Continuous Intergration)
- **공**동 소유권(Collective Ownership)
- **짝** 프로그래밍(Pair Programming)
- **디**자인 개선(Design Improvement) 또는 리팩토링(Refactoring)

---

## 2과목 : 소프트웨어 개발(20문제)
## 3과목 : 데이터베이스 구축(20문제)
## 4과목 : 프로그래밍 언어 활용(20문제)
## 5과목 : 정보시스템 구축 관리(20문제)